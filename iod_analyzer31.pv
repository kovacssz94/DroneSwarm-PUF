(* Channels *)
free c: channel. (* X <---> TTS *)
free d: channel. (* Follower <---> Leader *)
free e: channel. (* Leader <---> Ground Station *)
free f: channel. (* Public Key broadcast *)

(* Define types for IDs, nonces, messages, and MACs etc. *)
type nonce.
type ID.
type message.
type mac_val.  
type puf_response.
type init_points.
type sym_key.
type ciphertext.
type counter.
type sskey.
type spkey.
type mkey.
type host.

(* Type conversions *)
fun IDToMsg(ID): message.
fun PufToMsg(puf_response): message.

(*Initial events*)
event Drone_Start(ID, nonce, nonce).
event Leader_Forward(ID, ID, nonce, nonce).
(* Events for authentication *) 
event Di_Auth_DL_GS(message, nonce, nonce).
event DL_Auth_Di_GS(message, nonce, nonce).
event GS_Auth_Di_DL(message, ID, nonce, nonce).

(* Define cryptographic functions and primitives *)
fun H(puf_response, nonce): ID. (* generating AID *)
fun compute_mac(ID, puf_response, nonce, nonce): mac_val.(* MAC_i and MAC_L*)
fun compute_mac_GS(message, ID, puf_response, nonce, message, nonce): mac_val. (* MAC_GS with more values *)
fun compute_mac_L(message, message, message, nonce, nonce): mac_val. (* MAC_L2  *)
fun PUF_response(nonce): puf_response.
fun hash(message, message): message.
fun hash2(init_points, message): message.
fun F(puf_response): message.

(* Queries 
  Drone_Start() <== Leader_Forward() <== GS_Auth_Di_DL()
  GS_Auth_Di_DL() <== DL_Auth_Di_GS() <== Di_Auth_DL_GS() 
*)

(* DEBUG 
free test:bitstring [private].
query attacker(test).*)

query ACK_i: message, ACK_L: ID, ts3: nonce, AID_i: ID, AID_L: ID, ts2: nonce, ts1: nonce, session: nonce; 
  inj-event(GS_Auth_Di_DL(ACK_i, ACK_L, ts3, session)) ==> 
    (inj-event(Leader_Forward(AID_i, AID_L, ts2, session)) ==>
      inj-event(Drone_Start(AID_i, ts1, session))).

 
query ACK_i: message, ACK_L: ID, ts3: nonce, ts4: nonce, Auth_L: message, session: nonce; 
  inj-event(Di_Auth_DL_GS(ACK_i, ts4, session)) ==>
    (inj-event(DL_Auth_Di_GS(Auth_L, ts4, session)) ==>
      inj-event(GS_Auth_Di_DL(ACK_i, ACK_L, ts3, session))).

 (*
query session: nonce; 
  inj-event(Di_Auth_DL_GS(session)) ==>
    (inj-event(DL_Auth_Di_GS(session)) ==>
      (inj-event(GS_Auth_Di_DL(session)) ==>
        (inj-event(Leader_Forward(session)) ==>
          inj-event(Drone_Start(session))))). *)

table replay_table(nonce, nonce).
table session_table(nonce, nonce).

(* Drone *)
let drone(Di_Challenge: nonce) =
  let R_i = PUF_response(Di_Challenge) in
  (* Generate session key *)
  new session: nonce;
  new session_key: nonce;
  insert session_table(session_key, session);
  (* SEND message 1 *)
  new ts1: nonce;
  let AID_i = H(R_i, ts1) in
  let MAC_i = compute_mac(AID_i, R_i, ts1, session) in
  out(c, (AID_i, MAC_i, ts1, session_key));
  event Drone_Start(AID_i, ts1, session);

  (* Drone finish *)
  (* GET message 4 *)
  in(d, (Auth_L: message, ACK_i: message, Msg_GS: message, MAC_L2: mac_val, ts4: nonce));
  (* Timestamp validation *)
  get replay_table(sessionX, tsX) suchthat (sessionX = session && tsX = ts4) in
    0 (* Replay detected — already used *)
  else
    insert replay_table(session, ts4); 
  (* MAC validation *)
  if compute_mac_L(Auth_L, ACK_i, Msg_GS, ts4, session) = MAC_L2 then 
    (* Authenticate DL and GS *)
    if ACK_i = hash(PufToMsg(R_i), Auth_L) then 
      event Di_Auth_DL_GS(ACK_i, ts4, session).

(* Leader *)
let leader(DL_Challenge: nonce) =
  let R_L = PUF_response(DL_Challenge) in
  (* GET message 1 *)
  in(c, (AID_i: ID, MAC_i: mac_val, ts1: nonce, session_key: nonce));
  get session_table(=session_key, session) in
  (* Timestamp validation of message 1 *)
  get replay_table(sessionX, tsX) suchthat (sessionX = session && tsX = ts1) in
    0 (* Replay detected — already used *)
  else
    insert replay_table(session, ts1); 
  (* SEND message 2 *)
  new ts2: nonce;
  let AID_L = H(R_L, ts2) in
  let MAC_L = compute_mac(AID_L, R_L, ts2, session) in
  out(c, (AID_i, MAC_i, AID_L, MAC_L, ts1, ts2, session_key));
  event Leader_Forward(AID_i, AID_L, ts2, session);
  
  (* Leader auth *)
  (* GET message 3 *)
  in(c, (ACK_i: message, ACK_L: ID, Msg_GS: message, MAC_GS: mac_val, ts3: nonce));
  (* Timestamp validation of message 1 *)
  get replay_table(sessionX, tsX) suchthat (sessionX = session && tsX = ts3) in
    0 (* Replay detected — already used *)
  else
    insert replay_table(session, ts3); 
  (* MAC verification *)
  if compute_mac_GS(ACK_i, ACK_L, R_L, session, Msg_GS, ts3) = MAC_GS then 
    (* Authenticate Di and GS *)
    if ACK_L = H(R_L, ts3) then 
      (* SEND message 4 *)
      new ts4: nonce;
      let Auth_L = hash(PufToMsg(R_L), IDToMsg(ACK_L)) in
      let MAC_L2 = compute_mac_L(Auth_L, ACK_i, Msg_GS, ts4, session) in
      out(c, (Auth_L, ACK_i, Msg_GS, MAC_L2, ts4));
      event DL_Auth_Di_GS(Auth_L, ts4, session).

(* Ground Station *)
let ground_station(Di_Challenge: nonce, DL_Challenge: nonce, Points: init_points) =
  let R_i = PUF_response(Di_Challenge) in
  let R_L = PUF_response(DL_Challenge) in
  (* GET message 2 *)
  in(c, (AID_i: ID, MAC_i: mac_val, AID_L: ID, MAC_L: mac_val, ts1: nonce, ts2: nonce, session_key: nonce));
  get session_table(=session_key, session) in
  (* Timestamp validation *)
  get replay_table(sessionX, tsX) suchthat (sessionX = session && tsX = ts2) in
    0 (* Replay detected — already used *)
  else
    insert replay_table(session, ts2);
  
  (* Di and DL authentication *)
  if compute_mac(AID_i, R_i, ts1, session) = MAC_i && compute_mac(AID_L, R_L, ts2, session) = MAC_L then 
    if AID_i = H(R_i, ts1) && AID_L = H(R_L, ts2) then 
      (* SEND message 3 *)
      new ts3: nonce;
      let ACK_L = H(R_L, ts3) in
      let ACK_i = hash(PufToMsg(R_i), hash(PufToMsg(R_L), IDToMsg(ACK_L))) in
      let Y_i = F(R_i) in
      let Msg_GS = hash2(Points, Y_i) in
      let MAC_GS = compute_mac_GS(ACK_i, ACK_L, R_L, session, Msg_GS, ts3) in
      out(c, (ACK_i, ACK_L, Msg_GS, MAC_GS, ts3));
      event GS_Auth_Di_DL(ACK_i, ACK_L, ts3, session).

process
new Di_Challenge: nonce;
new DL_Challenge: nonce;
new Points: init_points;
  (* Launch an unbounded number of sessions of the other 3 participants *)
  !drone(Di_Challenge) |
  !leader(DL_Challenge) |
  !ground_station(Di_Challenge, DL_Challenge, Points)  

	